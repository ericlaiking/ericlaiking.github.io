<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>音頻產生器（含掃頻功能）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      line-height: 1.6;
      max-width: 600px; /* 讓手機版面更易讀 */
      margin: 0 auto;
    }
    label {
      display: block;
      margin-top: 10px;
    }
    button {
      margin-top: 15px;
      padding: 12px 22px; /* 加大按鈕，方便手機點擊 */
      font-size: 16px;
    }
    input, select {
      font-size: 16px; /* 避免在 iOS 上點擊時自動縮放 */
      padding: 5px;
    }
    input:disabled {
      background-color: #eee;
    }
  </style>
</head>
<body>
  <h2>音頻產生器（掃頻、持續播放、自訂波型）</h2>

  <label><input type="checkbox" id="sweep" onchange="toggleSweep()"> 啟用掃頻</label>
  <div id="sweep-controls" style="display:none;">
    <label>起始頻率 (Hz): <input type="number" id="startFreq" value="200"></label>
    <label>結束頻率 (Hz): <input type="number" id="endFreq" value="2000"></label>
  </div>

  <label id="freqLabel">頻率 (Hz): <input type="number" id="freq" value="1000"></label>
  <label>持續時間 (秒): <input type="number" id="duration" value="2" step="0.1"></label>
  <label>音量 (0 ~ 1): <input type="number" id="volume" value="1" step="0.01" min="0" max="1"></label>

  <label>波型:
    <select id="waveform">
      <option value="sine">正弦波 (sine)</option>
      <option value="square">方波 (square)</option>
      <option value="triangle">三角波 (triangle)</option>
      <option value="sawtooth">鋸齒波 (sawtooth)</option>
    </select>
  </label>

  <label><input type="checkbox" id="sustain" onchange="toggleDuration()"> 持續播放</label>

  <button onclick="startOscillator()">播放</button>
  <button onclick="stopOscillator()">停止</button>

    <script>
    let audioCtx;
    let oscillator;
    let gainNode;

    // --- 修改 1: 在頁面載入時就建立 AudioContext 和 GainNode ---
    // 這樣它們就可以在第一次使用者互動時被 "喚醒"
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.connect(audioCtx.destination);
    } catch (e) {
      alert('Web Audio API is not supported in this browser');
    }

    function toggleDuration() {
      const sustain = document.getElementById('sustain').checked;
      const durationInput = document.getElementById('duration');
      durationInput.disabled = sustain;
    }

    function toggleSweep() {
      const sweepEnabled = document.getElementById('sweep').checked;
      document.getElementById('sweep-controls').style.display = sweepEnabled ? 'block' : 'none';
      document.getElementById('freq').disabled = sweepEnabled;
      document.getElementById('freqLabel').style.color = sweepEnabled ? '#aaa' : '';
    }

    function startOscillator() {
      // --- 修改 2: 檢查並喚醒 AudioContext (行動裝置的關鍵) ---
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // 先停止目前可能在播放的聲音
      // 注意：我們不再呼叫完整的 stopOscillator()，因為我們不想斷開 GainNode
      if (oscillator) {
        try {
          oscillator.stop();
        } catch (e) {}
        oscillator.disconnect();
      }

      const volume = parseFloat(document.getElementById('volume').value);
      const waveform = document.getElementById('waveform').value;
      const sustain = document.getElementById('sustain').checked;
      const duration = sustain ? null : parseFloat(document.getElementById('duration').value);
      const sweep = document.getElementById('sweep').checked;

      // --- 修改 3: 不再建立 Ctx 和 GainNode，只建立 Oscillator ---
      oscillator = audioCtx.createOscillator();
      oscillator.type = waveform;

      // 設定音量 (GainNode 始終存在)
      gainNode.gain.cancelScheduledValues(audioCtx.currentTime); // 清除之前的音量設定
      gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

      oscillator.connect(gainNode);
      // gainNode 已在全域連接到 destination

      if (sweep) {
        const startFreq = parseFloat(document.getElementById('startFreq').value);
        const endFreq = parseFloat(document.getElementById('endFreq').value);
        oscillator.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
        if (!sustain && duration) {
          oscillator.frequency.linearRampToValueAtTime(endFreq, audioCtx.currentTime + duration);
        } else {
          // 持續播放時，掃頻時間預設為 2 秒 (原 5 秒可能太長)
          const sweepDuration = 2; 
          oscillator.frequency.linearRampToValueAtTime(endFreq, audioCtx.currentTime + sweepDuration);
        }
      } else {
        const freq = parseFloat(document.getElementById('freq').value);
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
      }

      oscillator.start();

      if (!sustain && duration) {
        oscillator.stop(audioCtx.currentTime + duration);
      }
    }

    function stopOscillator() {
      // --- 修改 4: 只停止和斷開振盪器 ---
      if (oscillator) {
        try {
          oscillator.stop();
        } catch (e) {}
        oscillator.disconnect();
        oscillator = null;
      }
      // 不再操作 gainNode 和 audioCtx
    }
  </script>
  </body>
</html>
